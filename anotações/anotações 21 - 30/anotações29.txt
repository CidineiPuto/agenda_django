Os forms do django permitem que crie forms de maneira seca, ou criar um form baseado no
contact.

Para criar um form, primeiro vamos importar;

    from django import forms

Dentro de forms tem classes que pode ser utilizada para criar formulários no django.
Agora, vamos criar nossa própria classe;

    class ContactForm(forms.(form, ou modelform) )

No caso, queremos um form baseado em um model, então ele não precisa ser criado do zero
por "form", por isso queremos um ModelForm um form baseado no nosso modelo.

    class ContactForm(forms.ModelForm)

Agora, vamos indicar o model, que seria o Contact.

    class Meta:
        model = Contact <-- Model usado
        fields = ( <-- Campos
            "first_name",
            "last_name",
            "phone",
        )

Lembre que model é a base de dados.
Agora, para usar esse form dentro do template, tem que ser passado no contexto.

SE não tivermos nenhuma instância do form, iremos apenas criar ele "seco".

    def create(request):
        context = {"form": ContactForm()}

Por enquanto nada foi mudado.
Agora, vamos fazer algo no html, iremos comentar o form, mas logo agora, iremos
usar os dados do form;

      <table>
        {{ form }}
      </table>

Assim já irá ter um form.
O django cria inputs com tr e td, por isso colocamos o form dentro de uma <table>.

Tem o "as_table" que é o padrão que estamos usando, e o "as_p". Que será criado parágrafo
para o input.

      <table>
        {{ form.as_p }}
      </table>

      ou

      <table>
        {{ form.as_table }}
      </table>

Com "p" pode ser tirado o table.
Mas nós não iremos trabalhar dessa maneira, iremos fazer o nosso próprio formulário.

Vamos tirar o campo de "last_name" que foi usado só para exemplo.
Nós queremos pegar os campos do nosso form, então, vamos fazer um for.

Usando um for no forms, recebemos os campos de volta do formulário, então recebemos
fields por fields, iremos receber name, last_name, e phone.
Iremos primeiramente envolver a div;

        {% for field in form %}
          <div class="form-group">
            <label for="id_first_name">First name</label>
            <input type="text" name="first_name" maxlength="255" id="id_first_name">
          </div>
        {% endfor %}

O for funcionou, então temos 3 vezes a mesma coisa, mas podemos fazer algo dinâmico,
preenchendo as coisas do div dinamicamente.
            <label for="{{ field.id_for_label }}">First name</label>

O id_for_label, é o id, do for deste label, para o campo de input.
Agora queremos o texto do label.

            <label for="{{ field.id_for_label }}">{{ field.label }}</label>

field.label, irá enviar o nome do label deste id, agora muda o nome.
Nós não precisamos fazer todo o input, é só usarmos;

        <label for="{{ field.id_for_label }}">{{ field.label }}</label>
        {{ field }}

Pois o field é o input.
Mas temos mais coisas para colocar, pois quando enviarmos os dados, iremos querer enviar
os dados para dentro do formulário dentro de context em "create".

Primeiramente, lá no contact_forms.py
No "create" vamos ver se o request method é post, se for, iremos fazer isso;

    if request.method == "POST":
        context = {"form": ContactForm(data=request.POST)}

Já o GET é template limpo.

    context = {"form": ContactForm()}

o form.post já sabe o que recebeu no input, então as coisas irão continuar lá.
Por isso paramos no return.

        return render(
            request,
            "contact/create.html",
            context,
        )

Mas isso só ocorre se a view for function.