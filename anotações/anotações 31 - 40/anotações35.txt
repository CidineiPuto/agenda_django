Lá no form do action, precisamos pegar essa url;
    action="{% url "contact:create" %}"

E queremos fazer o que ela faz dentro do template, mas fazer isso na view, para isso
vamos importar da urls do django o method reverse, com isso ele irá retornar uma url do
seu contato.

    from django.urls import reverse


Quando a pessoa for envair o form, queremos que a sua url venha dinamicamente de dentro
da view, pois vamos usar duas views diferentes, para criar e atualizar o contato, então
queremos renderizar o mesmo template.
Como será duas views diferentes iremos injetar dentro do template uma variável

    <form 
    action="{{ form_action }}"
    method="POST"
    enctype="multipart/form-data"
  >

Só que essa variável não está sendo enviada para dentro do template.
Por isso vamos criar ela;

    form_action = reverse("contact:create")
    if request.method == "POST":
        form = ContactForm(data=request.POST)
        context = {
            "form": form,
            "form_action": form_action,
        }

Porém, vamos perceber que a pessoa irá criar um contato, se ela for criar um contato
ela vai fazer um POST e vai cair dentro disso, nesse caso, quando estiver os dados do post
iremos salvar e depois redirecionar a página dentro do create de novo.


Iremos passar contact:update quando o form for valido.
        if form.is_valid():
            form.save()
            return redirect("contact:create",)

Primeiramente, vamos no urls, e criar uma url, iremos duplicar a do contact;

    path("contact/<int:contact_id>/update/", views.update, name="update"),

Agora, vamos ir no contact.forms.py

            contact = form.save()
            return redirect("contact:update", contact_id=contact.pk)

colocamos o form.save() dentro de uma variável, isso é justamente para usarmos o
contact_id=contact.pk 

Porém, vamos continuar colocando as coisas, para não dar erro no return do render;
    if request.method == "POST":
        ...
        context = {
            "form": form,
            "form_action": form_action,
        }
        ...
Se chegar no return render, será renderizado dentro da mesma página.
Podemos até fazer a mesma coisa no get.

    context = {
        "form_action": form_action,
        "form": ContactForm(),
    }

Vamos começar a criar as views;

def update(request, contact_id):
    form_action = reverse("contact:update", args=(contact_id,))

Começamos a passar os argumentos através de args.
Quando formos na classe do ContactForm é possível ver que em seu __init__
ele recebe mais do que apenas *args e **kwargs, quando chamamos o super.
Uma dessas coisas é o instance, quando passamos isso para o formulário, ele estará
criando o form só que já adrelado aos dados de uma instância que já existe, e quando salvo
a instância será atualizada.
Iremos usar o "get_object_or_404".

    contact = get_object_or_404(
        Contact,
        pk=contact_id, -> estamos selecionando do contato seu id, por isso iremos passar pk
        show=True,
    )

Se o contato não passar irá levantar um 404, ele irá pegar as coisas do "Contact",
será enviado o contact_id, e o show=True, para ele ser recebido só se o show for verdadeiro.

    if request.method == "POST":
        form = ContactForm(data=request.POST, instance=contact)

Agora, o que vier no POST, será para atualizar a instância que seria esse Contato.
Vamos mudar o context do get;

    context = {
        "form_action": form_action,
        "form": ContactForm(instance=contact),
    }
    return render(
        request,
        "contact/create.html",
        context,
    )

Pois se passou do is_valid() já temos o contato desse usuário.